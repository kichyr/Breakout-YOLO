<!DOCTYPE html>
<html>

<head>

    <meta charset="utf-8" />
    <title>BREAKOUT_GAME</title>

    <style> 
        body { padding: 0; margin: 0; } 
        canvas { background: #000000; display: block; margin: 0 auto; } 
        body {background-color: #000000}
		.canvasbox {
			position: absolute;
    		right: 10px;
    		top: 10px;
    		border-radius: 3px;
   			margin-right: 10px;
    		width: 215px;
    		height: 162px;
    		border-bottom: 3px solid #0063FF;
    		box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.2), 0 4px 10px 0 #00000030;
		}
    </style>

</head>

<body> 

    <form name='rating' action='/cgi-bin/view_menu.py'> </form>

    <h3><center>Super Game</center></h3>

<video class="canvasbox" id="myvideo"></video>
<canvas id="myCanvas" width="900" height="563"></canvas>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.7.4/dist/tf.min.js"> </script>

<script>

gesture_classes = ['fist', 'pistol', 'circle', 'finger up'];

class TinyYoloV3 {	
	
	/**
	@param {nObject} number of maximum object to recognize in one detection
	@param {scoreTh} score threshold
	@param {iouTh}   Intersect Over Union threshold
	*/
	constructor(nObject=4, scoreTh=0.5,  iouTh=0.3) {
		this.nObject = nObject
		this.scoreTh = scoreTh
		this.iouTh = iouTh
		this.anchor = [  82,93, 66,138, 118,125, 97,172, 133,193, 182,233 ]
		this.mask = { "3": [[6, 7, 8], [3, 4, 5], [0, 1, 2]],  "2": [[3, 4, 5], [0, 1, 2]] }
		this.labels = gesture_classes
		this.nClass = gesture_classes.length
	}

  	async load(url) {
		this.model = await tf.loadGraphModel(url)
    	console.log('Model loaded')
	}
	
	async predict(input, flipHorizontal=true) {
		this.imgSize = input.constructor.name === 'HTMLVideoElement' ? [input.videoHeight, input.videoWidth] : [input.height, input.width]
		//console.log(this.imgSize)
		
		let features = tf.tidy(() => {			
			//const canvas = document.createElement('canvas')
			//canvas.width = 416
			//canvas.height = 416	
			//const context = canvas.getContext('2d')
		  //context.drawImage(input, 0, 0, 416, 416)

			let imageTensor = tf.browser.fromPixels(input, 3)
			imageTensor = imageTensor.expandDims(0).toFloat().div(tf.scalar(255))
			imageTensor = tf.image.resizeBilinear(imageTensor, [192, 192])
			if(flipHorizontal){
				imageTensor = imageTensor.reverse(2)
			}

			const features = this.model.predict(imageTensor)
			return features
		})

		return features		
	}
	
	async detectAndBox(input, flipHorizontal=true) {
		const features = await this.predict(input, flipHorizontal)
		
		let [boxes, boxScores] = tf.tidy(() => {
			let nFeature = features.length
			let anchorMask = this.mask[nFeature]
			let inputShape = features[0].shape.slice(1, 3).map(num => num * 32)

			const anchors_tf = tf.tensor1d(this.anchor).reshape([-1, 2])
			let fBoxes = []
			let fScores = []

			for (let i = 0; i < nFeature; i++) {
				const anchorFeature = anchors_tf.gather(tf.tensor1d(anchorMask[i], 'int32'))
				const [boxes, boxScores] = this.getFeatureBox( features[i], anchorFeature, inputShape)

				fBoxes.push(boxes)
				fScores.push(boxScores)
			}

			fBoxes = tf.concat(fBoxes)
			fScores = tf.concat(fScores)

			return [fBoxes, fScores]
		})
		
		let boxCoord = []
		let scores = []
		let labelIdx = []

		const yPred = tf.argMax(boxScores, -1)
		const boxPred = tf.max(boxScores, -1)

		const nmsIndex = await tf.image.nonMaxSuppressionAsync(boxes, boxPred, this.nObject, this.iouTh, this.scoreTh)

		if (nmsIndex.size) {
			tf.tidy(() => {
				const classBoxes = tf.gather(boxes, nmsIndex)
				const classBoxScores = tf.gather(boxPred, nmsIndex)

				classBoxes.split(nmsIndex.size).map(box => {
					boxCoord.push(box.dataSync())
				})
				classBoxScores.dataSync().map(score => {
					scores.push(score)
				})
				labelIdx = yPred.gather(nmsIndex).dataSync()
			})
		}
		boxPred.dispose()
		yPred.dispose()
		nmsIndex.dispose()

		boxes.dispose()
		boxScores.dispose()
		return boxCoord.map((box, i) => {
			const top = Math.max(0, box[0])
			const left = Math.max(0, box[1])
			const bottom = Math.min(this.imgSize[0], box[2])
			const right = Math.min(this.imgSize[1], box[3])
			const height = bottom - top
			const width = right - left
			return { top, left, bottom, right, height, width, score:scores[i], label:this.labels[labelIdx[i]] }
		})
	}
	
	getFeatureBox( feature, featAnchor, inputShape ) {
		const nAnchors = featAnchor.shape[0]
		const anchors_tf = tf.reshape(featAnchor, [1, 1, nAnchors, 2])

		const gridShape = feature.shape.slice(1, 3)

		const gridY = tf.tile(tf.reshape(tf.range(0, gridShape[0]), [-1, 1, 1, 1]), [1, gridShape[1], 1, 1])
		const gridX = tf.tile(tf.reshape(tf.range(0, gridShape[1]), [1, -1, 1, 1]), [gridShape[0], 1, 1, 1])
		const grid = tf.concat([gridX, gridY], 3).cast(feature.dtype)

		feature = feature.reshape([gridShape[0], gridShape[1], nAnchors, this.nClass + 5])

		const [xy, wh, con, probs] = tf.split(feature, [2, 2, 1, this.nClass], 3)
		const boxXy = tf.div(tf.add(tf.sigmoid(xy), grid), gridShape.reverse())
		const boxWh = tf.div(tf.mul(tf.exp(wh), anchors_tf), inputShape.reverse())
		const boxConfidence = tf.sigmoid(con)

		let boxClassProbs = tf.sigmoid(probs)

		let boxYx = tf.concat(tf.split(boxXy, 2, 3).reverse(), 3)
		let boxHw = tf.concat(tf.split(boxWh, 2, 3).reverse(), 3)

		const boxMins = tf.mul(tf.sub(boxYx, tf.div(boxHw, 2)), this.imgSize)
		const boxMaxes = tf.mul(tf.add(boxYx, tf.div(boxHw, 2)), this.imgSize)

		let boxes = tf.concat([
			...tf.split(boxMins, 2, 3),
			...tf.split(boxMaxes, 2, 3)
		], 3)

		boxes = boxes.reshape([-1, 4])
		
		let boxScores = tf.mul(boxConfidence, boxClassProbs)
		boxScores = tf.reshape(boxScores, [-1, this.nClass])

		return [boxes, boxScores]
	}
}

function startVideo(video) {
  // Video must have height and width in order to be used as input for NN
  // Aspect ratio of 3/4 is used to support safari browser.
  	video.width = video.width || 640;
  	video.height = video.height || video.width * (3 / 4)

  	return new Promise(function (resolve, reject) {
    	navigator.mediaDevices
      		.getUserMedia({
        		audio: false,
        		video: {
          		facingMode: "user"
        		}
      		}).then(stream => {
        		//window.localStream = stream;
        		video.srcObject = stream
        		video.onloadeddata = () => {
          			video.play()
          			resolve(true)
        		}
      		}).catch(function (err) {
        		resolve(false)
      		});
  });
}

function beginVideo() {
	startVideo(video).then(function(status) {
		if(status) {
    		console.log("video on")
		}
	})
}

function renderPredictions(boxes, canvas, context, mediasource, flip) {

	context.clearRect(0, 0, canvas.width, canvas.height);
	canvas.width = mediasource.width;
	canvas.height = mediasource.height;
	//console.log("render", mediasource.width, mediasource.height)

	context.save();
	if (flip) {
  		context.scale(-1, 1);
  		context.translate(-mediasource.width, 0);
	}
	context.drawImage(mediasource, 0, 0, mediasource.width, mediasource.height);
	context.restore();
	context.font = '20px Arial';

	// console.log('number of detections: ', predictions.length);
	for (let i = 0; i < boxes.length; i++) {
  		context.beginPath();
  		context.fillStyle = "rgba(255, 255, 255, 0.6)";
  		context.fillRect(boxes[i]["left"], boxes[i]["top"] - 17, boxes[i]["width"], 17)
  		context.rect(boxes[i]["left"], boxes[i]["top"], boxes[i]["width"], boxes[i]["height"]);

  // draw a dot at the center of bounding box

  		context.lineWidth = 1;
  		context.strokeStyle = '#0063FF';
  		context.fillStyle = "#0063FF" // "rgba(244,247,251,1)";
  		context.fillRect(boxes[i]["left"] + (boxes[i]["width"] / 2), boxes[i]["top"] + (boxes[i]["height"] / 2), 5, 5)

  		context.stroke();
  		context.fillText(
    		boxes[i]["label"] + ": " + (Math.round(100*parseFloat(boxes[i]["score"]))/100).toString(),
    		boxes[i]["left"], boxes[i]["top"]);
	}

// Write FPS to top left
	//context.font = "bold 12px Arial"
	//context.fillText("[FPS]: " + FPS, 10, 20)
}

async function runDetection() {
    model.detectAndBox(video).then(boxes => {
		//var canvas = document.getElementById("myCanvas");
		//var context = canvas.getContext("2d");
		//renderPredictions(boxes, canvas, context, video, true)
		for (let i = 0; i < boxes.length; i++) {
			if (boxes[i]["label"] == "circle") {
				let midval = boxes[i]["left"] + boxes[i]["width"] / 2
				//лютый подгон под canvas
				midval = 1.5*midval - 5;
                prevMouseX = mouseX
                prevMouseY = mouseY
				recMouseX = midval;
                recMouseY = 1.2*(boxes[i]["top"] + boxes[i]["height"]/2)
			}
			else if (boxes[i]["label"] == "finger up") {
                if(mouseX > buttonX[0] && mouseX < buttonX[0] + buttonWidth[0] && mouseY > buttonY[0] && mouseY < buttonY[0] + buttonHeight[0]){
                    
                    //Постановка флага начала игры в sessionStorage
                    sessionStorage.setItem('levelcount', 1);

                    //Остановка музыки
                    mainMenuTheme.pause();

                    //Переход в файл game.html
                    document.location.href = "game.html";

                    //Удаление listener'ов для мыши
                    canvas.removeEventListener("mousemove", checkPos);
                    canvas.removeEventListener("mouseup", checkClick1);   
                }
			}
		}
        if(mouseX > buttonX[0] && mouseX < buttonX[0] + buttonWidth[0] && mouseY > buttonY[0] && mouseY < buttonY[0] + buttonHeight[0]){
                ballVisible = true;
                ballX[0] = buttonX[0] - (ballWidth/2) - 2;
                ballY[0] = buttonY[0]+40;
                ballX[1] = buttonX[0] + buttonWidth[0] + (ballWidth/2); 
                ballY[1] = buttonY[0]+40;

        }else
        if(mouseX > buttonX[1] && mouseX < buttonX[1] + buttonWidth[1] && mouseY > buttonY[1] && mouseY < buttonY[1] + buttonHeight[1]){
                ballVisible = true;
                ballX[0] = buttonX[1] - (ballWidth/2) - 2;
                ballY[0] = buttonY[1]+40;
                ballX[1] = buttonX[1] + buttonWidth[1] + (ballWidth/2); 
                ballY[1] = buttonY[1]+40;

        }else{
            ballVisible = false; 
            } 
	});
}

    var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d");
	var Pressed = false;							
	var flag = -1;
	
//Рисовалка рамки по периметру canvas
    function drawFrame(){
        //цвет линии
        ctx.strokeStyle = '#ffffff';
        //ширина линии
        ctx.lineWidth = 1;
        //Нарисовать прямоугольник  
        ctx.strokeRect(0, 0, 900, 563);
    }

//Слушатель позиции мышки
    canvas.addEventListener("mousemove", checkPos);

//Слушатели нажатия кнопки клавиатуры в меню	
	document.addEventListener("keydown", keyDownHandler, false); 							
	document.addEventListener("keyup", keyUpHandler, false);	 							
	
	function keyDownHandler(e) { 							
        if(e.keyCode == 66) {
            Pressed = true;
			flag += 1;
			if (flag == 3) {
				flag = 0;
			}
        }
    }

    function keyUpHandler(e) { 							
        if(e.keyCode == 66) {
            Pressed = false;
        }
    }
	
//Картинки для меню в качестве переменных
    var backgroundImage = new Image(); 
    var snowImage = new Image();   
    var logoImage = new Image();
	var yoloImage = new Image();
    var playImage = new Image();
    var ratingImage = new Image();
    var ballImage = new Image();

//timer
    var frames = 30;
    var timerId = 0;

//непосредственное обновление картинки через периодический вызов функции update
    //imerId = setInterval(update, 1000/frames);
    
//Переменные движения
    var backgroundY = 0;
    var speedSnow = 1;

//Переменные для тслеживания позиции мышки на экране
    var mouseX;
    var mouseY;

//Переменные для описания шарика и его положений
    var ballX = [0,0];
    var ballY = [0,0];
    var ballWidth = 50;
    var ballHeight = 50;
 
    var ballVisible = false;
    var ballSize = ballWidth;
    var ballRotate = 0;
    var ballRadius = 10;

//Переменные для размеров кнопок
    var buttonX = [205, 300];   //Положение по Х кнопок
    var buttonY = [220, 400];   //Положение по Y кнопок
    var buttonWidth = [300, 450];   //Ширина кнопки
    var buttonHeight = [100, 100];  //Высота кнопки

//Проверка нажатия мыши
    var fadeId = 0;
    canvas.addEventListener("mouseup", checkClick1);    //Listener для кнопки Play 
    canvas.addEventListener("mouseup", checkClick2);    //Listener для кнопки Rating

//переменная времени
    var time = 0.0;

//Сорсы картинок
    backgroundImage.src = "../images/background.png";
    logoImage.src = "../images/logo.png";  
	yoloImage.src = "../images/yolo.png";  
    playImage.src = "../images/play.png";
    ratingImage.src = "../images/rating.png";
    ballImage.src = "../images/ball.png";
    snowImage.src = "../images/snow.png";

//Инициализация массива изображений
	var Images = [];
	for(var i = 0; i < 3; i++) {
		Images[i] = new Image();
	}
	Images[0].src = "../images/background.png";
	Images[1].src = "../images/lvl1.png";
	Images[2].src = "../images/background1.png";


//Музыка меню
	var mainMenuTheme = new Audio('../sounds/main_menu_theme.mp3');
	var sound = 0;
    
  
//Функции отрисовки картинок на экран
    function drawbackground(){
		ctx.drawImage(backgroundImage, 0, 0);
    }
	
    //Выбор картинок фона из массива (Смена при нажатии кнопки B)
	function backgroundchanger(){ 
		if (Pressed == true) {
			if (flag == 0) {
				backgroundImage = Images[0];
				drawbackground();
			}
			else if (flag == 1) {
				backgroundImage = Images[1];
				drawbackground();
			}
			else if (flag == 2) {
				backgroundImage = Images[2];
				drawbackground();
			}
		}
	}

    function drawlogo() {
        ctx.drawImage(logoImage, 80, 50);
		ctx.drawImage(yoloImage, 550, 120, 150, 75);

    }

    function drawplay() {
        ctx.drawImage(playImage, 200, 220);
    }

    function drawrating() {
        ctx.drawImage(ratingImage, 300, 400);
    }

    function drawsnow() {
        ctx.drawImage(snowImage, 0, backgroundY - 563);
    }

//Обновление всей картинки и всего-всего
    function update() {
		if (sound == 0) {
			mainMenuTheme.play();
			sound++;
		}
		if (mainMenuTheme.ended == true) {
			sound = 0;
		}
        clear();
        move();
        step()
    }

    function step() {
        //requestAnimationFrame(step);
		draw();
        if (initial_seed % delay == 0) {
            initial_seed = initial_seed % delay;
            runDetection()
        }
        mouseX = mouseX + (recMouseX - prevMouseX)/delay
        mouseY = mouseY + (recMouseY - prevMouseY)/delay
        initial_seed++;
	}


//Описание функций для update()
    function clear(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function move(){
        backgroundY += speedSnow;
        if(backgroundY == 1 * canvas.height){
            backgroundY = 0;
        }
    }

    function drawCursor() {
		ctx.beginPath();

			ctx.arc(mouseX, mouseY, ballRadius, 0, Math.PI * 2);
			ctx.fillStyle = "blue";
			ctx.fill();

		ctx.closePath();
	}
//Функция рисования всего
    function draw(){
		if (Pressed == true) {		 							
			backgroundchanger();
		}
		drawbackground();
        drawFrame();
        drawsnow();
        drawlogo();
        drawplay();
        drawrating();
        if(ballVisible == true){
            ctx.drawImage(ballImage, ballX[0] - (ballSize/2), ballY[0], ballSize, ballHeight);
            ctx.drawImage(ballImage, ballX[1] - (ballSize/2), ballY[1], ballSize, ballHeight);
        }
        drawCursor();
    }

//Остальные возможности   
////////////////////////////////////////////////////////////////////////////
//Функция проверки положения мыши на экране в зависимости от положения кнопок
    function checkPos(mouseEvent){
        mouseX = mouseEvent.pageX - this.offsetLeft;
        mouseY = mouseEvent.pageY - this.offsetTop;

        if(mouseX > buttonX[0] && mouseX < buttonX[0] + buttonWidth[0] && mouseY > buttonY[0] && mouseY < buttonY[0] + buttonHeight[0]){
                ballVisible = true;
                ballX[0] = buttonX[0] - (ballWidth/2) - 2;
                ballY[0] = buttonY[0]+40;
                ballX[1] = buttonX[0] + buttonWidth[0] + (ballWidth/2); 
                ballY[1] = buttonY[0]+40;

        }else
        if(mouseX > buttonX[1] && mouseX < buttonX[1] + buttonWidth[1] && mouseY > buttonY[1] && mouseY < buttonY[1] + buttonHeight[1]){
                ballVisible = true;
                ballX[0] = buttonX[1] - (ballWidth/2) - 2;
                ballY[0] = buttonY[1]+40;
                ballX[1] = buttonX[1] + buttonWidth[1] + (ballWidth/2); 
                ballY[1] = buttonY[1]+40;

        }else{
            ballVisible = false; 
            } 
    }  

//Проверка нажатия мыши
//Проверка нажатия на кнопку PLAY
function checkClick1(mouseEvent){
            if(mouseX > buttonX[0] && mouseX < buttonX[0] + buttonWidth[0] && mouseY > buttonY[0] && mouseY < buttonY[0] + buttonHeight[0]){
                    
                    //Постановка флага начала игры в sessionStorage
                    sessionStorage.setItem('levelcount', 1);

                    //Остановка музыки
                    mainMenuTheme.pause();

                    //Переход в файл game.html
                    document.location.href = "game.html";

                    //Удаление listener'ов для мыши
                    canvas.removeEventListener("mousemove", checkPos);
                    canvas.removeEventListener("mouseup", checkClick1);   
            }
        }
//Проверка нажатия на кнопку RATING
function checkClick2(mouseEvent){
            if(mouseX > buttonX[1] && mouseX < buttonX[1] + buttonWidth[1] && mouseY > buttonY[1] && mouseY < buttonY[1] + buttonHeight[1]){

                    //Остановка музыки
                    mainMenuTheme.pause();

					//Submit для формы перехода в Rating
                    document.forms["rating"].submit();

                    //Удаление listener'ов для мыши
                    canvas.removeEventListener("mousemove", checkPos);
                    canvas.removeEventListener("mouseup", checkClick2);   
            }
        }
    
    var video = document.getElementById("myvideo");
	var canvas = document.getElementById("myCanvas");
    var prevMouseX = canvas.width/2
    var prevMouseY = canvas.height/2
    var recMouseX = canvas.width/2
    var recMouseY = canvas.height/2
    var delay = 2;
    var initial_seed = 0;
	var ctx = canvas.getContext("2d");
    var model = new TinyYoloV3();
	alert('START')
    model.load("http://127.0.0.1:5000/game/models/yolov3-tiny_12k_graph/model.json").then(model => {
	    beginVideo()
		//timeId = setInterval(step, videoInterval);
        timeId = setInterval(update, 1000/frames);
		//step()
	})

</script>

</body>

</html>
